================================================================================
  SZCZEGÓŁOWE WYJAŚNIENIE SKRYPTU - WZORCE PROJEKTOWE W C#
  System zarządzania bazami danych
================================================================================

SPIS TREŚCI:
1. Cel i zakres projektu
2. Wzorce projektowe - szczegółowe wyjaśnienie
3. Struktura klas i interfejsów
4. Przepływ działania programu
5. Odpowiedzi na najczęstsze pytania
6. Przykłady użycia
7. Glossary (słownik pojęć)

================================================================================
1. CEL I ZAKRES PROJEKTU
================================================================================

Projekt implementuje system zarządzania wieloma bazami danych z wykorzystaniem
trzech kluczowych wzorców projektowych:
- SINGLETON (dla menadżera połączeń)
- MULTITON (dla baz danych)
- OBJECT POOL (dla puli połączeń)

GŁÓWNE ZAŁOŻENIA:
- Klient nie ma bezpośredniego dostępu do baz danych
- Wszystkie operacje przechodzą przez ConnectionManager
- Liczba połączeń do każdej bazy jest ograniczona (max 3)
- Każda baza jest identyfikowana unikalną nazwą
- Wiele baz może działać jednocześnie w systemie

================================================================================
2. WZORCE PROJEKTOWE - SZCZEGÓŁOWE WYJAŚNIENIE
================================================================================

┌─────────────────────────────────────────────────────────────────────────┐
│ WZORZEC 1: SINGLETON (ConnectionManager)                                │
└─────────────────────────────────────────────────────────────────────────┘

CO TO JEST?
Singleton to wzorzec kreacyjny, który gwarantuje, że klasa ma tylko jedną
instancję w całym programie i zapewnia globalny punkt dostępu do niej.

DLACZEGO TU?
ConnectionManager zarządza wszystkimi połączeniami w systemie. Potrzebujemy
tylko jednego menadżera, który koordynuje dostęp do wszystkich baz.

JAK TO DZIAŁA?
1. Konstruktor jest prywatny - nikt nie może utworzyć instancji bezpośrednio
2. Statyczna zmienna przechowuje jedyną instancję
3. Statyczna metoda GetInstance() zwraca tę samą instancję zawsze
4. Double-checked locking zapewnia bezpieczeństwo wielowątkowe

KOD:
    private static ConnectionManager? instance;
    private static readonly object lockObject = new();
    
    private ConnectionManager() { } // prywatny konstruktor
    
    public static ConnectionManager GetInstance() {
        if (instance == null) {
            lock (lockObject) {
                if (instance == null) {
                    instance = new ConnectionManager();
                }
            }
        }
        return instance;
    }

PYTANIE: Dlaczego podwójne sprawdzanie (if)?
ODPOWIEDŹ: Pierwsze if oszczędza czas - jeśli instancja już istnieje, nie 
          blokujemy wątku. Drugie if wewnątrz lock zapewnia, że tylko jeden
          wątek utworzy instancję.

┌─────────────────────────────────────────────────────────────────────────┐
│ WZORZEC 2: MULTITON (Database)                                          │
└─────────────────────────────────────────────────────────────────────────┘

CO TO JEST?
Multiton to rozszerzenie Singletona. Zamiast jednej instancji, mamy wiele
instancji, ale każda jest identyfikowana unikalnym kluczem (w tym przypadku
nazwą bazy danych).

DLACZEGO TU?
Chcemy mieć możliwość korzystania z wielu baz danych (DB1, DB2, DB3...),
ale dla tej samej nazwy zawsze zwracać tę samą instancję bazy.

JAK TO DZIAŁA?
1. Dictionary przechowuje mapę: nazwa → instancja bazy
2. Konstruktor jest prywatny
3. GetInstance(string name) sprawdza czy baza o tej nazwie już istnieje
4. Jeśli tak - zwraca istniejącą, jeśli nie - tworzy nową

KOD:
    private static readonly Dictionary<string, Database> instances = new();
    private static readonly object lockObject = new();
    
    private Database(string name) { } // prywatny konstruktor
    
    public static Database GetInstance(string name) {
        lock (lockObject) {
            if (!instances.ContainsKey(name)) {
                instances[name] = new Database(name);
            }
            return instances[name];
        }
    }

PRZYKŁAD:
    Database db1a = Database.GetInstance("DB1"); // tworzy nową bazę DB1
    Database db1b = Database.GetInstance("DB1"); // zwraca istniejącą DB1
    Database db2 = Database.GetInstance("DB2");  // tworzy nową bazę DB2
    
    // db1a i db1b to TEN SAM OBIEKT!
    // db2 to INNY OBIEKT

┌─────────────────────────────────────────────────────────────────────────┐
│ WZORZEC 3: OBJECT POOL (ConnectionPool)                                 │
└─────────────────────────────────────────────────────────────────────────┘

CO TO JEST?
Object Pool to wzorzec, który zarządza zestawem gotowych do użycia obiektów.
Zamiast tworzyć i niszczyć obiekty, ponownie wykorzystuje istniejące.

DLACZEGO TU?
Połączenia do bazy są "drogie" w tworzeniu. Ograniczamy ich liczbę do 3
na bazę i wykorzystujemy je cyklicznie.

JAK TO DZIAŁA?
1. Pula tworzy maksymalnie 3 połączenia
2. Pierwsze 3 żądania tworzą nowe połączenia (1, 2, 3)
3. Czwarte żądanie zwraca połączenie #1 (cykl: 1→2→3→1→2→3...)
4. Wszystkie połączenia działają na tej samej bazie danych

KOD:
    private readonly List<IDatabaseConnection> connections;
    private int currentConnectionIndex = 0;
    private readonly int maxConnections = 3;
    
    public IDatabaseConnection GetConnection() {
        lock (lockObject) {
            if (connections.Count < maxConnections) {
                // Twórz nowe połączenie
                var newConnection = new DatabaseConnection(database, connections.Count + 1);
                connections.Add(newConnection);
                return newConnection;
            }
            
            // Zwróć istniejące połączenie cyklicznie
            var connection = connections[currentConnectionIndex];
            currentConnectionIndex = (currentConnectionIndex + 1) % maxConnections;
            return connection;
        }
    }

PRZYKŁAD DZIAŁANIA:
    Żądanie 1 → Tworzy Connection #1
    Żądanie 2 → Tworzy Connection #2
    Żądanie 3 → Tworzy Connection #3
    Żądanie 4 → Zwraca Connection #1 (ponowne użycie)
    Żądanie 5 → Zwraca Connection #2
    Żądanie 6 → Zwraca Connection #3
    Żądanie 7 → Zwraca Connection #1
    ...

================================================================================
3. STRUKTURA KLAS I INTERFEJSÓW
================================================================================

HIERARCHIA OBIEKTÓW:

┌──────────────────────────────────────────────────────────────┐
│                    ConnectionManager                          │
│                     (SINGLETON)                               │
│  - Jeden w całym systemie                                    │
│  - Zarządza dostępem do wszystkich baz                       │
└────────────────────┬─────────────────────────────────────────┘
                     │
        ┌────────────┼────────────┐
        │            │            │
┌───────▼──────┐ ┌──▼──────────┐ ┌▼────────────┐
│ Database DB1 │ │ Database DB2│ │Database DB3 │
│ (MULTITON)   │ │ (MULTITON)  │ │(MULTITON)   │
└──────┬───────┘ └──────┬──────┘ └──────┬──────┘
       │                │               │
┌──────▼──────────┐ ┌───▼──────────┐ ┌─▼───────────┐
│ ConnectionPool  │ │ConnectionPool│ │ConnectionPool│
│ (OBJECT POOL)   │ │(OBJECT POOL) │ │(OBJECT POOL)│
│ Max 3 połączenia│ │Max 3 połącz. │ │Max 3 połącz.│
└──────┬──────────┘ └───┬──────────┘ └──┬──────────┘
       │                │               │
   ┌───┴───┬────┐   ┌───┴───┬────┐  ┌──┴────┬────┐
   │       │    │   │       │    │  │       │    │
   Conn1 Conn2 Conn3 Conn1 Conn2 Conn3 Conn1 Conn2 Conn3


INTERFEJSY:

interface IConnectionManager {
    // Zwraca połączenie do bazy o podanej nazwie
    IDatabaseConnection GetConnection(string databaseName);
}

interface IDatabaseConnection {
    // Operacje CRUD na bazie danych
    int AddRecord(string name, int age);
    void UpdateRecord(int id, string newName, int newAge);
    void DeleteRecord(int id);
    Record? GetRecord(int id);
    void ShowAllRecords();
}


KLASY:

class Record
    └─ Przechowuje dane: ID, Name, Age
    └─ Prosty obiekt wartości (Value Object)

class ConnectionManager : IConnectionManager
    └─ SINGLETON
    └─ Zarządza dostępem do wszystkich baz
    └─ Deleguje tworzenie połączeń do Database

class Database
    └─ MULTITON (klucz: nazwa bazy)
    └─ Przechowuje rekordy w List<Record>
    └─ Posiada własną ConnectionPool
    └─ Generuje unikalne ID dla rekordów

class ConnectionPool
    └─ OBJECT POOL
    └─ Zarządza pulą połączeń (max 3)
    └─ Zwraca połączenia cyklicznie

class DatabaseConnection : IDatabaseConnection
    └─ Implementuje operacje na bazie
    └─ Posiada referencję do Database
    └─ Ma unikalny ConnectionId

================================================================================
4. PRZEPŁYW DZIAŁANIA PROGRAMU
================================================================================

SCENARIUSZ 1: Pierwsze połączenie do nowej bazy
─────────────────────────────────────────────────

1. Klient: ConnectionManager.GetInstance()
   └→ ConnectionManager sprawdza czy instancja istnieje
   └→ Jeśli nie - tworzy nową (tylko raz!)
   └→ Zwraca instancję

2. Klient: connectionManager.GetConnection("DB1")
   └→ ConnectionManager woła Database.GetInstance("DB1")
   └→ Database sprawdza słownik instances
   └→ "DB1" nie istnieje, więc tworzy nową bazę
   └→ Przy tworzeniu bazy tworzy się ConnectionPool (max 3)
   └→ Database zwraca się do ConnectionPool

3. ConnectionPool.GetConnection()
   └→ Sprawdza: connections.Count < maxConnections?
   └→ TAK (0 < 3), więc tworzy nowe DatabaseConnection
   └→ Dodaje do listy connections
   └→ Zwraca DatabaseConnection #1

4. Klient używa połączenia:
   connection1.AddRecord("Jan", 25)
   └→ DatabaseConnection woła metody na Database
   └→ Rekord zostaje dodany do List<Record>


SCENARIUSZ 2: Czwarte połączenie do tej samej bazy
─────────────────────────────────────────────────────

1. Klient: connectionManager.GetConnection("DB1")
   └→ ConnectionManager woła Database.GetInstance("DB1")
   └→ Database znajduje "DB1" w słowniku - zwraca ISTNIEJĄCĄ bazę

2. ConnectionPool.GetConnection()
   └→ Sprawdza: connections.Count < maxConnections?
   └→ NIE (3 < 3 = false), więc NIE TWORZY nowego
   └→ Zwraca connections[currentConnectionIndex]  // index = 0
   └→ To jest Connection #1 (pierwsze połączenie!)
   └→ Zwiększa currentConnectionIndex: (0 + 1) % 3 = 1

3. Efekt: connection4 === connection1 (ten sam obiekt!)


DIAGRAM SEKWENCJI dla connection4:

Klient          ConnectionManager    Database(DB1)    ConnectionPool
  |                    |                   |                |
  |--GetConnection---->|                   |                |
  |    ("DB1")         |                   |                |
  |                    |--GetInstance----->|                |
  |                    |    ("DB1")        |                |
  |                    |<--returns DB1-----|                |
  |                    |                   |                |
  |                    |--GetConnection------------------->|
  |                    |                   |                |
  |                    |                   |  [Pool pełna]  |
  |                    |                   |  Zwraca Conn#1 |
  |                    |<--------------returns Connection#1-|
  |<--returns Conn#1---|                   |                |
  |                    |                   |                |

================================================================================
5. ODPOWIEDZI NA NAJCZĘSTSZE PYTANIA
================================================================================

Q1: Dlaczego ConnectionManager jest Singletonem, a Database Multitonem?
───────────────────────────────────────────────────────────────────────
A: ConnectionManager to centralny punkt zarządzania - potrzebujemy tylko
   jednego. Database może być wiele (różne bazy), ale dla tej samej nazwy
   chcemy mieć tę samą instancję. Gdyby Database był zwykłą klasą, moglibyśmy
   przypadkowo stworzyć dwie bazy "DB1" i miałyby różne dane. Multiton to
   zapobiega.

Q2: Co się stanie jeśli poproszę o 10 połączeń do jednej bazy?
──────────────────────────────────────────────────────────────
A: Stworzonych zostanie tylko 3 fizyczne połączenia. Połączenia 4-10 będą
   ponownie wykorzystywać te 3 istniejące w kolejności cyklicznej:
   Połączenie #4 = Połączenie #1
   Połączenie #5 = Połączenie #2
   Połączenie #6 = Połączenie #3
   Połączenie #7 = Połączenie #1
   itd.

Q3: Czy różne połączenia widzą te same dane?
────────────────────────────────────────────
A: TAK! Wszystkie połączenia do tej samej bazy (np. DB1) operują na tej samej
   instancji Database, więc widzą te same rekordy. Jeśli connection1 doda
   rekord, to connection2 i connection3 też go zobaczą.

Q4: Dlaczego używamy lock w kodzie?
───────────────────────────────────
A: Lock zapewnia thread-safety (bezpieczeństwo wielowątkowe). Jeśli dwa wątki
   jednocześnie wywołają GetInstance(), lock gwarantuje, że tylko jeden wątek
   wejdzie do sekcji krytycznej i utworzy instancję. Bez lock mogłyby powstać
   dwie instancje, co złamałoby wzorzec Singleton/Multiton.

Q5: Co to znaczy "double-checked locking"?
──────────────────────────────────────────
A: To optymalizacja. Sprawdzamy if (instance == null) dwa razy:
   1. PRZED lock - szybkie sprawdzenie bez blokowania
   2. WEWNĄTRZ lock - upewnienie się, że inny wątek nie utworzył instancji
   
   Bez pierwszego if, każde wywołanie blokowałoby wątek (wolniejsze).

Q6: Dlaczego ConnectionPool jest w Database, a nie w ConnectionManager?
───────────────────────────────────────────────────────────────────────
A: Każda baza powinna mieć własną pulę połączeń. Jeśli pula byłaby w
   ConnectionManager, limit 3 połączeń dotczyłby WSZYSTKICH baz razem,
   a nie każdej osobno. Chcemy: max 3 do DB1 + max 3 do DB2 + max 3 do DB3.

Q7: Jak działa operator % (modulo) w cyklicznym zwracaniu połączeń?
───────────────────────────────────────────────────────────────────
A: currentConnectionIndex = (currentConnectionIndex + 1) % maxConnections
   
   Przykład dla maxConnections = 3:
   (0 + 1) % 3 = 1
   (1 + 1) % 3 = 2
   (2 + 1) % 3 = 0  ← wraca do początku!
   (0 + 1) % 3 = 1
   ...
   To tworzy cykl: 0 → 1 → 2 → 0 → 1 → 2 → ...

Q8: Co się stanie jeśli usunę rekord przez connection1, a potem spojrzę
    przez connection2?
────────────────────────────────────────────────────────────────────────
A: Rekord zniknie! Wszystkie połączenia do tej samej bazy operują na tej
   samej List<Record>, więc usunięcie jest widoczne wszędzie natychmiast.

Q9: Czy mogę mieć więcej niż 3 połączenia w puli?
─────────────────────────────────────────────────
A: TAK! W konstruktorze ConnectionPool jest parametr maxConnections:
   
   connectionPool = new ConnectionPool(this, 3);
                                             ↑
                                    zmień tę liczbę
   
   Możesz to zmienić na 5, 10, lub dowolną liczbę.

Q10: Co to są metody internal w klasie Database?
────────────────────────────────────────────────
A: To metody pomocnicze dostępne tylko w tym samym assembly (projekcie).
   DatabaseConnection używa ich do operacji na bazie, ale kod zewnętrzny
   nie może ich wywołać. To enkapsulacja - ukrywamy szczegóły implementacji.

Q11: Dlaczego Main() ma tyle testów?
────────────────────────────────────
A: Testy demonstrują wszystkie wymagania zadania:
   ✓ Singleton działa (GetInstance zwraca ten sam obiekt)
   ✓ Multiton działa (ta sama nazwa → ta sama baza)
   ✓ Object Pool działa (max 3 połączenia)
   ✓ Cykliczne ponowne użycie (connection4 == connection1)
   ✓ Współdzielenie danych (wszystkie połączenia widzą te same rekordy)
   ✓ Izolacja baz (DB1, DB2, DB3 są niezależne)

Q12: Czy to jest thread-safe?
─────────────────────────────
A: TAK, dla operacji tworzenia instancji (używamy lock). Ale operacje
   na rekordach (Add, Update, Delete) NIE SĄ thread-safe. W produkcyjnym
   kodzie trzeba by dodać lock również tam, jeśli wiele wątków jednocześnie
   modyfikuje dane.

Q13: Co się stanie jeśli wywołam GetConnection() na różnych wątkach?
────────────────────────────────────────────────────────────────────
A: Dzięki lock w GetConnection() tylko jeden wątek na raz może tworzyć
   nowe połączenie. Pozostałe czekają. To zapobiega tworzeniu więcej niż
   3 połączeń.

Q14: Dlaczego konstruktory są prywatne?
───────────────────────────────────────
A: To część wzorców Singleton i Multiton. Prywatny konstruktor uniemożliwia
   tworzenie instancji z zewnątrz (przez `new`). Jedyna droga to przez
   GetInstance(), co daje nam kontrolę nad liczbą instancji.

Q15: Czy mogę zmienić DatabaseConnection z klasy na strukturę?
──────────────────────────────────────────────────────────────
A: NIE! Struktury w C# są typami wartości (kopiowane), a klasy typami
   referencyjnymi. Object Pool potrzebuje referencji - chcemy, aby
   connection4 wskazywało na TEN SAM obiekt co connection1, nie kopię.

================================================================================
6. PRZYKŁADY UŻYCIA
================================================================================

PRZYKŁAD 1: Podstawowe użycie
──────────────────────────────
// Pobierz menadżera (singleton)
ConnectionManager manager = ConnectionManager.GetInstance();

// Pobierz połączenie
IDatabaseConnection conn = manager.GetConnection("MojaBaza");

// Dodaj rekordy
conn.AddRecord("Jan", 25);
conn.AddRecord("Anna", 30);

// Wyświetl wszystkie
conn.ShowAllRecords();


PRZYKŁAD 2: Weryfikacja Singletona
───────────────────────────────────
var manager1 = ConnectionManager.GetInstance();
var manager2 = ConnectionManager.GetInstance();

// Oba wskazują na TEN SAM obiekt
Console.WriteLine(ReferenceEquals(manager1, manager2)); // True


PRZYKŁAD 3: Weryfikacja Multitona
──────────────────────────────────
var db1a = Database.GetInstance("DB1");
var db1b = Database.GetInstance("DB1");
var db2 = Database.GetInstance("DB2");

Console.WriteLine(ReferenceEquals(db1a, db1b)); // True - ta sama baza
Console.WriteLine(ReferenceEquals(db1a, db2));  // False - różne bazy


PRZYKŁAD 4: Test puli połączeń
───────────────────────────────
var manager = ConnectionManager.GetInstance();

var c1 = manager.GetConnection("TestDB"); // Tworzy nowe #1
var c2 = manager.GetConnection("TestDB"); // Tworzy nowe #2
var c3 = manager.GetConnection("TestDB"); // Tworzy nowe #3
var c4 = manager.GetConnection("TestDB"); // Zwraca #1 (ponownie)

Console.WriteLine(ReferenceEquals(c1, c4)); // True!


PRZYKŁAD 5: Współdzielenie danych
──────────────────────────────────
var conn1 = manager.GetConnection("SharedDB");
var conn2 = manager.GetConnection("SharedDB");

conn1.AddRecord("Użytkownik1", 25);
conn2.ShowAllRecords(); // Widzi rekord dodany przez conn1!


PRZYKŁAD 6: Izolacja baz
─────────────────────────
var connA = manager.GetConnection("BazaA");
var connB = manager.GetConnection("BazaB");

connA.AddRecord("Rekord w A", 10);
connB.AddRecord("Rekord w B", 20);

connA.ShowAllRecords(); // Pokazuje tylko rekord z BazaA
connB.ShowAllRecords(); // Pokazuje tylko rekord z BazaB


PRZYKŁAD 7: Operacje CRUD
──────────────────────────
var conn = manager.GetConnection("CrudDB");

// CREATE
int id1 = conn.AddRecord("Jan", 25);
int id2 = conn.AddRecord("Anna", 30);

// READ
Record? record = conn.GetRecord(id1);
if (record != null) {
    Console.WriteLine(record);
}

// UPDATE
conn.UpdateRecord(id1, "Jan Kowalski", 26);

// DELETE
conn.DeleteRecord(id2);

// SHOW ALL
conn.ShowAllRecords();

================================================================================
7. GLOSSARY (SŁOWNIK POJĘĆ)
================================================================================

SINGLETON
    Wzorzec kreacyjny zapewniający, że klasa ma tylko jedną instancję
    w całym programie.

MULTITON
    Rozszerzenie Singletona - wiele instancji, każda identyfikowana
    unikalnym kluczem.

OBJECT POOL
    Wzorzec zarządzający zestawem gotowych do użycia obiektów,
    ponownie wykorzystując je zamiast tworzyć nowe.

THREAD-SAFE
    Kod bezpieczny dla wielu wątków - nie powoduje błędów gdy wiele
    wątków wykonuje go jednocześnie.

DOUBLE-CHECKED LOCKING
    Optymalizacja sprawdzająca warunek dwa razy: przed i po zablokowaniu
    dostępu.

LOCK
    Mechanizm synchronizacji - tylko jeden wątek może być w sekcji
    krytycznej jednocześnie.

ASSEMBLY
    Skompilowana jednostka kodu w .NET (plik .dll lub .exe).

INTERNAL
    Modyfikator dostępu - widoczny tylko w tym samym assembly.

INTERFACE
    Kontrakt definiujący zestaw metod, które klasa musi zaimplementować.

CRUD
    Create, Read, Update, Delete - podstawowe operacje na danych.

REFERENCE EQUALITY
    Dwa obiekty są równe gdy wskazują na TEN SAM obiekt w pamięci.

VALUE TYPE
    Typ przechowujący wartość bezpośrednio (struct, int, bool).

REFERENCE TYPE
    Typ przechowujący referencję do obiektu w pamięci (class).

ENCAPSULATION
    Ukrywanie szczegółów implementacji, udostępnianie tylko interfejsu.

LAZY INITIALIZATION
    Tworzenie obiektu dopiero gdy jest potrzebny (nie od razu).

================================================================================
PODSUMOWANIE KLUCZOWYCH KONCEPTÓW
================================================================================

1. ConnectionManager (SINGLETON)
   └─ Jedna instancja w systemie
   └─ Punkt dostępu do wszystkich baz

2. Database (MULTITON)
   └─ Wiele instancji (jedna per nazwa)
   └─ Współdzielona przez wszystkie połączenia o tej samej nazwie

3. ConnectionPool (OBJECT POOL)
   └─ Maksymalnie 3 połączenia per baza
   └─ Cykliczne ponowne wykorzystanie

4. DatabaseConnection
   └─ Implementuje operacje CRUD
   └─ Współdzieli dane z innymi połączeniami do tej samej bazy

5. Przepływ: Klient → ConnectionManager → Database → ConnectionPool → Connection

6. Bezpieczeństwo: Lock zapewnia thread-safety dla tworzenia instancji

7. Korzyści:
   ✓ Kontrola nad liczbą instancji
   ✓ Oszczędność zasobów (ponowne użycie połączeń)
   ✓ Centralne zarządzanie dostępem
   ✓ Bezpieczeństwo wielowątkowe
   ✓ Łatwa rozbudowa (nowe bazy bez zmian w kodzie)

================================================================================
AUTOR: System zarządzania bazami danych z wzorcami projektowymi
DATA: 2025-10-25
JĘZYK: C# (.NET 9.0)
================================================================================
